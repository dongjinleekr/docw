#!/usr/bin/env bash

# The docw command script

# initialize env
BASE_DIR=$(dirname $(dirname $(readlink -f $0)))
. ${BASE_DIR}/common.sh

print_usage() {
  echo ""
  echo "Usage: docw [<command>] [<options>]"
  echo ""
  echo "  where command is one of:"
  echo "    ls                   display current status."
  echo "    make                 create node(s)"
  echo "    format               format node(s)"
  echo "    set                  configure node(s)"
  echo "    rm                   remove node(s)"
  echo ""
  echo "  All commands print help when invoked without parameters, or with -h"
  echo ""
}

print_ls_usage() {
  echo ""
  echo "Usage: docw ls [<options>]"
  echo ""
  echo "  where options are one of:"
  echo "    <cluster>            display <cluster>'s information."
  echo "    --all                display all clusters' and nodes' information."
  echo ""
}

print_make_usage() {
  echo ""
  echo "Usage: docw make [<options>]"
  echo ""
  echo "  where options are one of:"
  echo "    node <hostname> <size>   create node sized <size> and named <hostname>"
  echo "    nodes <count> <size>     create <count> nodes at once, sized <size>. hostnames are assigned automatically."
  echo "    cluster <name> <hostname>*   create cluster <name> with given hosts."
  echo ""
  echo "  <size> is specified by the number of cores of desired node size."
  echo "  For details, please refer https://www.digitalocean.com/pricing/"
  echo ""
}

print_format_usage() {
  echo ""
  echo "Usage: docw format [<options>]"
  echo ""
  echo "  where options are one of:"
  echo "    <hostname>*              format all given nodes."
  echo ""
  echo "  The format process includes:"
  echo "    1. configure given node's root password."
  echo "    2. Add the node to /etc/hosts."
  echo "    3. setup password-less login with the node."
  echo ""
}

print_set_usage() {
  echo ""
  echo "Usage: docw set <clustername> <role> [<options>]"
  echo ""
  echo "  where role are one of:"
  echo "    hadoop                   setup hadoop cluster. namenode hostname should be given as an option."
  echo ""
}

print_rm_usage() {
  echo ""
  echo "Usage: docw rm [<options>]"
  echo ""
  echo "  where options are one of:"
  echo "    cluster <clustername>    remove all nodes that belongs to <clustername>."
  echo ""
}

make_node() {
	[ "$#" -eq 2 ] || return 1
	
	HOSTNAME=$1
	SIZE=$2
	
	return 0
}

make_nodes() {
	[ "$#" -eq 2 ] || return 1
	
	SIZE=$1
	NODECOUNT=$2

	ID_START=$(cat ${ID_SEQUENCE_PATH})
	ID_END=$((${ID_START} + ${NODECOUNT} - 1))
	ID_NEXT=$((${ID_END} + 1))
	
	echo ${ID_NEXT} > ${ID_SEQUENCE_PATH}

	PID_LIST=""
	for I in $(seq ${ID_START} ${ID_END})
	do
		HOSTNAME=$(printf ${HOSTNAME_PREFIX} ${I})
		create_node ${HOSTNAME} ${SIZE} &
	PID_LIST=${PID_LIST}' '$!
	done
	
	wait_all ${PID_LIST}

	return 0
}

setup_hadoop_cluster() {
	[ "$#" -eq 2 ] || return 1
	
	CLUSTER_NAME=$1
	MASTER_HOSTNAME=$2
	
	configure_hadoop_slave_all ${CLUSTER_NAME} ${MASTER_HOSTNAME}
	configure_hadoop_master ${CLUSTER_NAME} ${MASTER_HOSTNAME}
	
	return 0
}

rm_cluster() {
	[ "$#" -eq 1 ] || return 1
	
	CLUSTER_NAME=$1
	
	unregister_and_destroy_cluster ${CLUSTER_NAME}
	
	return 0
}

process_ls() {

	case $1 in
		"--all")
			display_all_clusters_info
		
			RETVAL=$?
			[ "${RETVAL}" -eq 0 ] && return 0
			;;
		"")
			print_ls_usage
			return 0
			;;
		-h)
			print_ls_usage
			return 0
			;;
		*)
			CLUSTER_NAME=$1
			display_cluster_info ${CLUSTER_NAME}
			
			RETVAL=$?
			[ "${RETVAL}" -eq 0 ] && return 0
			;;
	esac
	
	return 1
}

process_make() {
	COMMAND=$1
	shift 1
	
	case $COMMAND in
		node)
			make_node $@
		
			RETVAL=$?
			[ "${RETVAL}" -eq 0 ] && return 0
			;;
		nodes)
			make_nodes $@
		
			RETVAL=$?
			[ "${RETVAL}" -eq 0 ] && return 0
			;;
		cluster)
			CLUSTER_NAME=$1
			shift 1
			
			for HOSTNAME in $@
			do
				assign_to_namespace ${CLUSTER_NAME} ${HOSTNAME}
				assign_to_cluster ${CLUSTER_NAME} ${HOSTNAME}
				setup_hosts ${CLUSTER_NAME}
			done
		
			RETVAL=$?
			[ "${RETVAL}" -eq 0 ] && return 0
			;;
		"")
			print_make_usage
			return 0
			;;
		-h)
			print_make_usage
			return 0
			;;
		*)
			return 1
			;;
	esac
}

process_format() {
	
	case $1 in
		"--all")
			echo 'not implemented yet'
			;;
		"")
			print_format_usage
			return 0
			;;
		-h)
			print_format_usage
			return 0
			;;
		*)
			for HOSTNAME in $@
			do
				format_node ${HOSTNAME}
			done
	
			return 0
			;;
	esac
}

process_set() {
	COMMAND=$1
	shift 1
	
	case $COMMAND in
		hadoop)
			setup_hadoop_cluster $@
		
			RETVAL=$?
			if [ "${RETVAL}" -eq 0 ]; then
				set_cluster_role $1 hadoop
				return 0
			else
				return 1
			fi
			;;
		"")
			print_set_usage
			return 0
			;;
		-h)
			print_set_usage
			return 0
			;;
		*)
			return 1
			;;
	esac
}

process_rm() {
	COMMAND=$1
	shift 1
	
	case $COMMAND in
		cluster)
			rm_cluster $@
		
			RETVAL=$?
			# todo: remove from registry
			# if [ "${RETVAL}" -eq 0 ]; then
			# else
			# fi
			
			return 0
			;;
		"")
			print_rm_usage
			return 0
			;;
		-h)
			print_rm_usage
			return 0
			;;
		*)
			return 1
			;;
	esac
}

case $1 in
  "")
		print_usage
		exit 0
		;;
	-h)
		print_usage
		exit 0
		;;
	ls)
		shift 1
		process_ls $@
		
		RETVAL=$?
		[ "${RETVAL}" -eq 0 ] && exit 0
		;;
	make)
		shift 1
		process_make $@
		
		RETVAL=$?
		[ "${RETVAL}" -eq 0 ] && exit 0
		;;
	format)
		shift 1
		process_format $@
		
		RETVAL=$?
		[ "${RETVAL}" -eq 0 ] && exit 0
		;;
	set)
		shift 1
		process_set $@
		
		RETVAL=$?
		[ "${RETVAL}" -eq 0 ] && exit 0
		;;
	rm)
		shift 1
		process_rm $@
		
		RETVAL=$?
		[ "${RETVAL}" -eq 0 ] && exit 0
		;;
	*)
		print_usage 1>&2
		exit 1
		;;
esac
